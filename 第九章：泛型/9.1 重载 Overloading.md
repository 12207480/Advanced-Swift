
# 第九章：泛型 Generics


## 9.1 重载 Overloading
to be done.

### 自由函数的重载 Overload Resolution for Free Functions 
这一小段讲的主要是```泛型的重载```相关知识点

    /// 泛型打印view的相关信息
    ///
    /// - Parameter view: view
    func log<View: UIView>(_ view: View) {
        print("It's a \(type(of: view)), frame: \(view.frame)")
    }
    
    ///对泛型的重写
    func log(_ view: UILabel) {
        let text = view.text ?? "(empty)"
        print("It's a label, text: \(text)")
    }
    
    let label = UILabel(frame: .zero)
    label.text = "liaoworking is handsome~~"
    let button = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 101))
    
    log(label) //It's a label, text: liaoworking is handsome~~
    log(button) //It's a UIButton, frame: (0.0, 0.0, 100.0, 101.0)

上面这个demo没毛病对吧，只要我们重载了一个泛型方法， 在打印对于的类型时就调用这个方法。
那我们看看上面方法的```下面的使用场景```

    let views = [label, button] // Type of views is [UIView] for view in views {
    
    for view in views {
        log(view)
    }
    
    /*
     It's a UILabel, frame: (20.0, 20.0, 200.0, 32.0)
     It's a UIButton, frame: (0.0, 0.0, 100.0, 50.0)
     */

咦~为嘛在for循环中就无法去区分方法了??? 手动黑人问号脸。 

原因：泛型的重载在```编译时期```就确定的。并不是在runtime时候动态确定。 就会有上面的差异。


### 运算符的重载  Overload Resolution for Operators
to be continue...



